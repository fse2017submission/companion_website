<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="The " Dark Side " of Code Refactoring">
    <meta name="author" content="Diego Cedrim">

    <title>The "Dark Side" of Code Refactoring</title>

    <!-- Bootstrap core CSS -->
    <link href="bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="grid.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="bower_components/highlightjs/styles/xcode.css">
    <script src="bower_components/highlightjs/highlight.pack.min.js"></script>
    <script src="bower_components/jquery/dist/jquery.min.js"></script>
    <script src="bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
    <script>
        hljs.initHighlightingOnLoad();
    </script>

    <style type="text/css">
        pre {
            border: none;
            background: #ffffff;
            padding: 0px;
        }
        
        .col-md-6 {
            background: #ffffff;
            border: none;
            padding-bottom: 0px;
        }
        
        body {
            padding-top: 70px;
            position: relative;
        }
    </style>

    <script type="text/javascript">
        $(document).ready(function() {
            $('body').scrollspy({
                target: '#mainNavBar'
            })
        });
    </script>
</head>

<body>
    <nav id="mainNavBar" class="navbar navbar-default navbar-fixed-top">
        <div class="container-fluid">

            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-6">
                <ul class="nav navbar-nav">
                    <li><a href="#abstract">Abstract</a></li>
                    <li><a href="#examples">Examples</a></li>
                    <li><a href="#classification">Classification</a></li>
                    <li><a href="#refactored_elements">Refactored Elements</a></li>
                    <li><a href="#manual_validation">Validation</a></li>
                    <li><a href="#root_floss">Root/Floss</a></li>
                    <li><a href="#downloads">Downloads</a></li>
                    <li><a href="#thresholds">Rules</a></li>
                    <li><a href="#references">References</a></li>
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
    </nav>


    <div class="container">

        <div class="page-header" id="title">
            <h1>The "Dark Side" of Code Refactoring<br/><small>Revealing When Refactoring Stinks</small></h1>
        </div>
        This website contains complementary data to the submitted paper.

        <h3 class="page-header" id="abstract">Abstract</h3>

        <p class="text-justify">Code smells in a program represent indications of structural quality problems, which can be addressed by software refactoring. There is an explicit assumption that software refactoring improves the structural quality of a program by reducing its
            density of code smells. However, little has been reported about whether and to what extent developers neglect or end up creating code smells through refactoring. This paper reports a longitudinal study intended to address this gap. We analyze
            how often commonly-used refactoring types affect the density of 13 types of code smells along the version histories of 23 projects. Our findings are based on the analysis of 16,566 refactorings distributed in 10 different types. Even though
            79.4% of the refactorings touched smelly elements, 57% did not reduce their occurrences. Surprisingly, only 9.7% of refactorings removed smells, while 33.3% induced the introduction of new ones. More than 95% of such refactoring-induced smells
            were not removed in successive commits, which suggest refactorings tend to more frequently introduce long-living smells instead of eliminating existing ones. We also characterized and quantified typical refactoring-smell patterns, and observed
            that certain harmful patterns are very frequent, including (but not limited to): (i) approximately 30% of the Move Method and Pull Up Method tended to induce the emergence of God Class in the target classes without removing smells in the source
            classes, and (ii) the Extract Superclass refactoring creates the code smell Speculative Generality in 68% of the cases.</p>

        <h3 class="page-header" id="examples">Motivating Examples</h3>

        <p class="text-justify">Code smells are anomalies in the program structure. A code smell is a surface indication that usually corresponds to a deeper problem in the system. There are different types of code smells documented in the literature <a href="#references">[1]</a>.
            For instance, lets suppose a single class with several responsibilities. A class with this symptom is hard to read and evolve. This type of smell is known as God Class. Another common anomaly is when a method has many parameters. This code
            smell is known as Long Parameter List. A method with this symptom is also hard to read and evolve.</p>

        <div class="row">
            <div class="col-md-6">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Figure 1: Person class with God Class code smell</h3>
                    </div>
                    <div class="panel-body" style="text-align: center;">
                        <img src="img/person-a.png" width="40%" alt="Person class with God Class code smell" class="img-rounded">
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Figure 2: Class after Extract Class refactoring without God Class</h3>
                    </div>
                    <div class="panel-body" style="text-align: center;">
                        <img src="img/person-b.png" width="90%" alt="Person class after Extract Class refactoring without God Class" class="img-rounded">
                    </div>
                </div>
            </div>

        </div>

        <p class="text-justify">Figures 1 and 2 show the Person class in two different forms. In Figure 1, the Person class has at least three attributes representing two loosely-coupled concepts: person and telephone number. This version of Person can be considered a God Class.
            In order to remove this code smell, the developer can extract part of the class structure it into another class: TelephoneNumber (Figure 2). After this transformation, the program no longer has a God Class and still realize the same functionality.
            As the program have a code smell in Figure 1, its new internal structure represented in Figure 2 has a better structural quality.
        </p>

        <p class="text-justify">Projects with low structural quality are hard to read and maintain. Therefore, whenever a code smell is identified in a program, a change should be made to remove it. Refactoring is a structural change intended to remove a code smell without changing
            its observable behavior <a href="#references">[1]</a>. There are several claims associated with the benefits of software refactoring, which is all implicitly associated with its capability of improving the software structural quality.</p>

        <p class="text-justify">In fact, refactoring is a common practice <a href="#references">[3]</a> intended to improve code quality attributes <a href="#references">[2]</a>. Code smells are widely used for detecting refactoring opportunities <a href="#references">[4]</a>.
            Existing studies highlight that developers can use refactoring to improve structural quality by eliminating code smells in software <a href="#references">[5]</a> <a href="#references">[6]</a>. Let’s consider the Figures 1 and 2 again to illustrate
            this scenario. As mentioned before, the module Person in Figure 1 has a God Class code smell. This happened because this class is accumulating responsibilities that should be fulfilled by two classes. In order to address this smell, the Extract
            Class refactoring should be performed, i.e., a programmer could create a new class and move the relevant fields and methods from the old class into the new one. This refactoring, in this case, would remove the God Class code smell. Since the
            number of code smells would be reduced, this refactoring would improve the software structural quality.</p>

        <div class="row">
            <div class="col-md-6">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Listing 1: Deserializer method using a temp variable</h3>
                    </div>
                    <div class="panel-body">
                        <pre><code class="java">public Double deserialize(JsonParser j) {
    JsonNode node = j.getCodec().readTree();
    return node.get("x").val();
}</code></pre>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="panel panel-default">
                    <div class="panel-heading">
                        <h3 class="panel-title">Listing 2: Deserializer method after Inline Temp refactoring</h3>
                    </div>
                    <div class="panel-body">
                        <pre><code class="java">public Double deserialize(JsonParser j) {
    return j.getCodec().readTree().get("x").val();
}</code></pre>
                    </div>
                </div>
            </div>

        </div>



        <p class="text-justify">There is a list of refactoring types documented in literature <a href="#references">[1]</a>. Figures 1 and 2 illustrate the Extract Class refactoring type. Another refactoring type is the Inline Temp. In order to use this refactoring, a temporary
            variable assigned to once with a simple expression must exist. Listing 1 presents a method responsible for deserializing a piece of JSON code into a Java object. This method uses a temporary variable (node) to return the desired value. This
            variable is used only in the next line of the method. Therefore, a developer could apply the Inline Temp refactoring to get rid of this variable. As result of this refactoring, the node variable disappears and the resulting method only contains
            one line (Listing 2).</p>




        <p class="text-justify">In this case, a new code smell was introduced by the code change being accomplished by the programmer. The code presented in Listing 1 has no code smells, but the resulting code presented in Listing 2 has one. A call to getCodec method is firstly
            made. After that, three additional method calls are made in the same chain. This is a code smell know as Message Chain. Navigating through method calls this way means the code is coupled to the structure of the navigation. Therefore, any change
            in the object graph structure would affect this piece of code. In practice, refactoring may not be effective in some cases as this example illustrates. In this way, refactoring may not improve or maintain the structural quality and, worse,
            it may introduce new code smells. Lets consider again Listings 1 and 2. In this scenario, the Inline Temp refactoring removed an apparently unnecessary temporary variable, but introduced a new code smell on the software. Consequently, this
            refactoring degraded the program structural quality. This is an example of how refactoring may not be effective.</p>


        <h3 class="page-header" id="classification">Refactoring Classification</h3>

        <p class="text-justify">Both aforementioned examples presented cases where refactorings have had interference on the existence of code smells. Code smells were removed in the first case (Figures 1 and 2). In the second case, a new code smell instance emerged. These scenarios
            show how refactoring can interfere positively or negatively in the existence of code smells. The application of a refactoring may contribute to the degradation of structural quality (Listings 1 and 2). In this way, we can classify a single
            refactoring by looking how it changed the existing code smells. In order to show how this can be made, lets formally define it.</p>

        <p class="text-justify">Let S = {s<sub>1</sub>,s<sub>2</sub>,···,s<sub>n</sub>} be the set of software projects to be evaluated. Each software s has a set of versions V(s) = {v1, v2, &hellip; , v<sub>m</sub>}. Each version vi has a set of elements E(v<sub>i</sub>) =
            {e
            <sub>1</sub>, e<sub>2</sub>, &hellip;} representing all methods, classes and fields belonging to it. In Figures 1 and 2, the set S = {PhoneBook} is composed just by one software. This software PhoneBook has two versions V(PhoneBook) = {v<sub>a</sub>,
            v
            <sub>b</sub>} represented by Figures 1 and 2, respectively. Finally, each version vi<sub>i</sub> has a set of elements E(v<sub>i</sub>) composed by Person and TelephoneNumber classes, methods and fields.</p>

        <p class="text-justify">In order to be able to detect refactorings we must analyze transformations between each subsequent pair of versions. In this way, we assume R is a refactoring detection function where R(v<sub>i</sub>, v<sub>i+1</sub>) = {r<sub>1</sub>(rt<sub>1</sub>;
            e
            <sub>1</sub>), &hellip;, r<sub>k</sub>(rt<sub>k</sub>; e<sub>k</sub>)} gives us a set of tuples composed by two elements: the refactoring type (rt) and the set of refactored elements represented by e. So, the function R give us all refactoring
            activities detected in a pair of software versions. If we apply the R function in the PhoneBook software, the result would be R(v<sub>a</sub>,v<sub>b</sub>) = {r<sub>1</sub>(Extract Class,e')} where e' = {Person, TelephoneNumber}.</p>

        <p class="text-justify">Let CS be a code smell detection function where CS(e) = {cs<sub>1</sub>,&hellip;} returns a set of code smells present in a software element set e. As the objective is to classify refactorings, the classifying procedure will only analyze code
            smells related to elements affected by a refactoring. In this way, we can say that CS<sub>b[r]</sub>(e) is the set of code smells of e before the application of the refactoring r. On the other hand, CS<sub>a[r]</sub>(e) is the set of code
            smells found after the application of r. Considering r<sub>1</sub> refactoring applied on classes of PhoneBook system, CS function would present the following results: CS<sub>b[r<sub>1</sub>]</sub>({Person}) = {God Class} and CS<sub>a[r<sub>1</sub>]</sub>({Person,TelephoneNumber})
            = &empty;.</p>

        <p class="text-justify">Using data collected by the functions defined before, it is possible to classify a refactoring by looking how it interferes in existing code smells. Suppose e is a software element set, r is a refactoring activity and |CS<sub>b[r]</sub>(e)|= x.
            After r refactoring, |CS<sub>a[r]</sub>(e)|= y. Depending on x and y, it is possible to classify r. If x > y, r reduced the number of code smells on e and, because of that, r is a <strong>positive refactoring</strong>. In other way, if x &lt;
            y, r increased the number of code smells on e and, because of that, r is a <strong>negative refactoring</strong>. When x = y, r is a <strong>neutral refactoring</strong>. This classification is summarized in the following table.</p>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Condition</th>
                    <th>Classification</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td> |CS<sub>b[r]</sub>(e)| > |CS<sub>a[r]</sub>(e)| </td>
                    <td> Positive Refactoring </td>
                </tr>
                <tr>
                    <td> |CS<sub>b[r]</sub>(e)| &lt; |CS<sub>a[r]</sub>(e)| </td>
                    <td> Negative Refactoring </td>
                </tr>
                <tr>
                    <td> |CS<sub>b[r]</sub>(e)| = |CS<sub>a[r]</sub>(e)| </td>
                    <td> Neutral Refactoring </td>
                </tr>
            </tbody>
        </table>

        <h3 class="page-header" id="refactored_elements">Refactored Elements</h3>


        <p class="text-justify"> In this work, it is considered as refactored elements all those directly affected by the refactoring. If a refactoring is applied only in a method body, only this method is considered as refactored element. For instance, lets consider the Move
            Method refactoring. In this refactoring type, a method m is moved from class A to B. Hence, the considered refactored elements in this case would be {m, A, B}. All m method callers are affected by this refactoring, but we do not consider them
            as refactored elements. As another example, let us consider the Rename Method refactoring. In this scenario, a new name is given to the method m and the refactored element set would be just {m}. For each refactoring type a different refactored
            element set is used. In the following table, we present the considered refactored elements for each type of refactoring. </p>

        <table class="table table-striped">
            <thead>
                <tr>
                    <th>Refactoring</th>
                    <th>Refactored Elements</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td> Extract Interface </td>
                    <td> classes implementing the new interface. </td>
                </tr>
                <tr>
                    <td> Extract Method </td>
                    <td> (i) method created; (ii) method from where the new method was extracted; and (iii) class containing both methods. </td>
                </tr>
                <tr>
                    <td> Extract Superclass </td>
                    <td> (i) classes extending the new class; and (ii) new class created. </td>
                </tr>
                <tr>
                    <td> Inline Method </td>
                    <td> (i) the method which received the new code; and (ii) class containing the method. </td>
                </tr>
                <tr>
                    <td> Move Field </td>
                    <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
                </tr>
                <tr>
                    <td> Move Method </td>
                    <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
                </tr>
                <tr>
                    <td> Pull Up Field </td>
                    <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
                </tr>
                <tr>
                    <td> Pull Up Method </td>
                    <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
                </tr>
                <tr>
                    <td> Push Down Field </td>
                    <td> the two classes affected by the change: the class which the field used to reside and the class which received the field. </td>
                </tr>
                <tr>
                    <td> Push Down Method </td>
                    <td> the two classes affected by the change: the class which the method used to reside and the class which received the method. </td>
                </tr>
                <tr>
                    <td> Rename Method </td>
                    <td> the renamed method and the class that contains it. </td>
                </tr>
            </tbody>
        </table>


        <h3 class="page-header" id="manual_validation">Manual Validation</h3>

        <p class="text-justify">The following Table presents the sample sizes of the refactorings manually analyzed by type and the precision obtained to each one. In general, it was observed a high precision for each refactoring type, with a median of 88.36% (excluding rename
            method). The precision found in all refactoring types are close/inside the standard deviation (7.73). Applying the Grubb outlier test (alpha=0.05) we could not find any outlier, indicating that no refactoring type is strongly influencing the
            median precision found. Thus, the results found to the representative sample analyzed represent a key factor to provide reliability to the other results reported in this work.
            <p>

                <table class="table table-striped">
                    <tr>
                        <th><strong>Ref. type</strong></th>
                        <th><strong>pop. size</strong></th>
                        <th><strong>sample size</strong></th>
                        <th><strong>precision</strong></th>
                    </tr>
                    <tr>
                        <td>Rename method</td>
                        <td>12,752</td>
                        <td>373</td>
                        <td>95.17%</td>
                    </tr>
                    <tr>
                        <td>Extract method</td>
                        <td>7,517</td>
                        <td>366</td>
                        <td>80.60%</td>
                    </tr>
                    <tr>
                        <td>Move field</td>
                        <td>4,356</td>
                        <td>353</td>
                        <td>96.88%</td>
                    </tr>
                    <tr>
                        <td>Inline method</td>
                        <td>1,528</td>
                        <td>307</td>
                        <td>75.57%</td>
                    </tr>
                    <tr>
                        <td>Move method</td>
                        <td>1,404</td>
                        <td>302</td>
                        <td>88.08%</td>
                    </tr>
                    <tr>
                        <td>Pull up method</td>
                        <td>629</td>
                        <td>239</td>
                        <td>78.66%</td>
                    </tr>
                    <tr>
                        <td>Pull up field</td>
                        <td>465</td>
                        <td>211</td>
                        <td>98.58%</td>
                    </tr>
                    <tr>
                        <td>Extract superclass</td>
                        <td>342</td>
                        <td>181</td>
                        <td>93.92%</td>
                    </tr>
                    <tr>
                        <td>Extract interface</td>
                        <td>133</td>
                        <td>99</td>
                        <td>87.88%</td>
                    </tr>
                    <tr>
                        <td>Push down method</td>
                        <td>114</td>
                        <td>88</td>
                        <td>88.64%</td>
                    </tr>
                    <tr>
                        <td>Push down field</td>
                        <td>78</td>
                        <td>65</td>
                        <td>96.92%</td>
                    </tr>
                </table>


                <h3 class="page-header" id="root_floss">Root Canal Refactoring vs. Floss Refactoring</h3>

                <p class="text-justify">We used Eclipse and the eGit plugin to categorize a transformation (root or floss). We selected a sample containing 730 transformations, and added in our web site. For each transformation in our sample, three authors of the paper manually
                    categorize them. We selected the id commit of the resulting program, and used eGit to find it. By using the diff tool, we manually analyzed all changes in all classes modified in the scope. When a behavioral change was identified,
                    we filled a form explaining it and classified the change as floss. When we did not find a behavioral change, we searched for other refactoring activities and indicated in the form.
                    <p>




                        <h3 class="page-header" id="downloads">Downloads</h3>
                        <table class="table table-striped">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Artefact</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">1</th>
                                    <td> <a href="download/projects.xlsx" target="_blank">Projects Analyzed</a></td>
                                    <td> Name, URL, number of versions and LOC of all analyzed projects. We provide the date and hash of the last commit analyzed </td>
                                </tr>
                                <tr>
                                    <th scope="row">2</th>
                                    <td> <a href="download/fse_paper.pdf" target="_blank">Submited Paper</a></td>
                                    <td> Complete text submited to FSE 2017</td>
                                </tr>
                                <tr>
                                    <th scope="row">3</th>
                                    <td> <a href="download/non-removal-patterns.xlsx" target="_blank">Non-Removal Patterns</a></td>
                                    <td> Complete list of non-removal patterns</td>
                                </tr>

                            </tbody>
                        </table>


                        <h3 class="page-header" id="thresholds">Code Smells Rules</h3>
                        <p class="text-justify"> <a href="http://www.springer.com/us/book/9783540244295">Lanza et al.</a> originally proposed the rules presented in the following tables. <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6498466&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6498466">Macia et al.</a>                            adapted these rules and evaluated the thresholds in another work. Two sets of thresholds were used in order to collect code smells using these rules. The first set, as known as <strong>tight</strong>, represent the thresholds
                            previously validated in the study by <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6498466&url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D6498466">Macia et al.</a>. We quality this strategy
                            as tight because it relies on the use of high thresholds values aiming to detect only critical code smells across the projects. The second strategy, named as <strong>relaxed</strong>, uses relaxed thresholds aiming to detect
                            as many code smells as possible. These relaxed thresholds represent lower bound thresholds, which were tuned through our validation phase. These two strategies allowed to derive refactoring classifications based on two different
                            sets of code smells. The following table presents all thresholds used during code smell detection phase.</p>


                        <table class="table table-striped">
                            <caption>Tight thresholds.</caption>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Code Smell</th>
                                    <th>Rule</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">1</th>
                                    <td> Long Method</td>
                                    <td> (LOC &gt; 50) and (CC &gt; 5) </td>
                                </tr>
                                <tr>
                                    <th scope="row">2</th>
                                    <td> Shotgun Surgery</td>
                                    <td> (CC &gt; 4) and (FanOut &gt; 7) </td>
                                </tr>
                                <tr>
                                    <th scope="row">3</th>
                                    <td> Feature Envy</td>
                                    <td> (CC &gt; 4) and (FanOut &gt; 4) and (LCOM &lt; 30%) </td>
                                </tr>
                                <tr>
                                    <th scope="row">4</th>
                                    <td> Divergent Change:</td>
                                    <td> (FanIn &gt; 10) and (LCOM &lt; 50%) and (CC &gt; 4) </td>
                                </tr>
                                <tr>
                                    <th scope="row">5</th>
                                    <td> God Class</td>
                                    <td> [(LOC &gt; 150) and (CBO &gt; 6)] or [(NOM &gt; 15) and (CBO &gt; 6)] </td>
                                </tr>
                            </tbody>
                        </table>

                        <table class="table table-striped">
                            <caption>Relaxed thresholds.</caption>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Code Smell</th>
                                    <th>Rule</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">1</th>
                                    <td> Long Method</td>
                                    <td> (LOC &gt; 50) and (CC &gt; 3) </td>
                                </tr>
                                <tr>
                                    <th scope="row">2</th>
                                    <td> Shotgun Surgery</td>
                                    <td> (CC &gt; 3) and (FanOut &gt; 4) </td>
                                </tr>
                                <tr>
                                    <th scope="row">3</th>
                                    <td> Feature Envy</td>
                                    <td> (CC &gt; 3) and (FanOut &gt; 3) and (LCOM &lt; 50%) </td>
                                </tr>
                                <tr>
                                    <th scope="row">4</th>
                                    <td> Divergent Change:</td>
                                    <td> (FanIn &gt; 5) and (LCOM &lt; 60%) and (CC &gt; 3) </td>
                                </tr>
                                <tr>
                                    <th scope="row">5</th>
                                    <td> God Class</td>
                                    <td> [(LOC &gt; 150) and (CBO &gt; 6)] or [(NOM &gt; 15) and (CBO &gt; 6)] </td>
                                </tr>
                            </tbody>
                        </table>

                        <p class="text-justify">As described in the paper, we also used another set of rules to detect code smells. The third set of rules and thresholds was proposed by <a href="http://dl.acm.org/citation.cfm?id=2808301">Bavota et al.</a> The following table
                            presents the rules extracted from this paper.</p>

                        <table class="table table-striped">
                            <caption>Bavota's Rules</caption>
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Code Smell</th>
                                    <th>Rule</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <th scope="row">1</th>
                                    <td> Class data should be private</td>
                                    <td> A class having at least one public field. </td>
                                </tr>
                                <tr>
                                    <th scope="row">2</th>
                                    <td> Complex class</td>
                                    <td> A class having at least one method for which McCabe cyclomatic complexity is higher than 10. </td>
                                </tr>
                                <tr>
                                    <th scope="row">3</th>
                                    <td> Feature envy</td>
                                    <td> All methods having more calls with another class than the one they are implemented.</td>
                                </tr>
                                <tr>
                                    <th scope="row">4</th>
                                    <td> God class</td>
                                    <td> All classes having (i) cohesion lower than the average of the system AND (ii) LOCs > 500.</td>
                                </tr>
                                <tr>
                                    <th scope="row">5</th>
                                    <td> Lazy class</td>
                                    <td> All classes having LOCs lower than the first quartile of the distribution of LOCs for all system’s classes. </td>
                                </tr>
                                <tr>
                                    <th scope="row">6</th>
                                    <td> Long method</td>
                                    <td> All methods having LOCs higher than the average of the system. </td>
                                </tr>
                                <tr>
                                    <th scope="row">7</th>
                                    <td> Long parameter list</td>
                                    <td> All methods having a number of parameters higher than the average of the system. </td>
                                </tr>
                                <tr>
                                    <th scope="row">8</th>
                                    <td> Message chain</td>
                                    <td> All chains of methods’ calls longer than three. </td>
                                </tr>
                                <tr>
                                    <th scope="row">9</th>
                                    <td> Refused bequest</td>
                                    <td> All classes overriding more than half of the methods inherited by a superclass. </td>
                                </tr>
                                <tr>
                                    <th scope="row">10</th>
                                    <td> Spaghetti code</td>
                                    <td> A class implementing at least two long methods (see previous rule) interacting between them through method calls or shared fields.</td>
                                </tr>
                                <tr>
                                    <th scope="row">11</th>
                                    <td> Speculative generality</td>
                                    <td> A class declared as abstract having less than three children classes using its methods. </td>
                                </tr>
                            </tbody>
                        </table>

                        <h3 class="page-header" id="references" id="references">References</h3>

                        <p class="text-justify"><strong>[1]</strong> M. Fowler, K. Beck, J. Brant, W. Opdyke, and D. Roberts, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=311424">Refactoring: Improving the Design of Existing Code</a>, 1 edition. Boston, MA, USA:
                            Addison-Wesley Longman Publishing Co., Inc., 1999.</p>

                        <p class="text-justify"><strong>[2]</strong> F. Bourquin and R. K. Keller, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=4145033">“High-impact Refactoring Based on Architecture Violations,”</a> in 11th European Conference
                            on Software Maintenance and Reengineering (CSMR’07), 2007, pp. 149–158.</p>

                        <p class="text-justify"><strong>[3]</strong> Z. Xing and E. Stroulia, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=1173032">“Refactoring Practice: How it is and How it Should be Supported - An Eclipse Case Study,”</a> in 2006 22nd IEEE International
                            Conference on Software Maintenance, 2006, pp. 458–468.</p>

                        <p class="text-justify"><strong>[4]</strong> M. Zhang, T. Hall, and N. Baddoo, <a target="_blank" href="http://dl.acm.org/citation.cfm?id=1967086">“Code Bad Smells: a review of current knowledge,”</a> J. Softw. Maint. Evol. Res. Pract., vol. 23, no. 3,
                            pp. 179–202, Apr. 2011.</p>

                        <p class="text-justify"><strong>[5]</strong> R. Kolb, D. Muthig, T. Patzke, and K. Yamauchi, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=1510132">“A case study in refactoring a legacy component for reuse in a product line,”</a>                            in 21st IEEE International Conference on Software Maintenance (ICSM’05), 2005, pp. 369–378.</p>

                        <p class="text-justify"><strong>[6]</strong> P. Meananeatra, <a target="_blank" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=6494967">“Identifying refactoring sequences for improving software maintainability,”</a> in Proceedings of the
                            27th IEEE/ACM International Conference on Automated Software Engineering - ASE 2012, 2012, p. 406.</p>

    </div>
    <!-- /container -->

    <script>
        (function(i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function() {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-69581400-1', 'auto');
        ga('send', 'pageview');
    </script>

</body>

</html>